# Vue基础第四天笔记

## 反馈

## 复习

## 基础-表格案例-axios-搜索功能-分析

>**`目标`** 通过分析得出 计算属性**`不能进行搜索功能分析`**的结论
>
>后台搜索 => 异步请求 => 不能立刻返回 ![img](assets/002AA665.png) 
>
>前后台搜索=> 模糊搜索
>
>计算属性=> 异步操作搜索=>返回结果 XXXXX 走不通
>
>因为**`计算属性必须要有返回值`**
>
>结论: 搜索功能不能采用 **`计算属性`** 进行解决
>
>计算属性中一定是**`同步操作`**,如果有**`异步`**操作,则该业务逻辑就会失败
>
>新知识: 监听属性 watch => 监听属性

## 基础-实例选项-watch-文档分析

> **`目标`**:掌握watch 选项的基本功能含义
>
> 场景: 当需要根据数据变化 进行相应业务操作,且该操作是**`异步操作`**时,计算属性不能再使用,可以使用监听watch特性
>
>   **`监控谁就写谁的名字`** key(监控名称):value(函数 => 当name值发生改变时就会执行)
>
>   函数有两个参数 newValue(新值) oldValue(旧值)
>
> watch => Vue实例的选项 和el/data/methods并列
>
> Vue实例 data/methods/computed 不可重名=> 但是**`watch 一定要重名`**

## 基础-实例选项-watch-基本使用

>**`目标-任务`**-: 实现路径:city值发生改变时  生成新name的list
>
>​      1   实现 city的双向绑定  
>
>​        2  watch监听city的数据项改变 
>
>​        3  改变函数中实现 
>
>* 计算属性和watch区别
>* 计算属性 必须要有返回值 所以说不能写异步请求 因为有人用它的返回值(插值表达式)
>* watch选项中可以写很多逻辑 不需要返回值 因为没有人用它的返回值
>
>代码
>
>```js
>watch: {
>//newValue是最新的值 oldValue为后面的旧值
>city(newValue, oldValue) {
>  this.list = this.list.map(item => ({
>    name: item.name,
>    group: newValue
>  }));
>}
>}
>```
>
>

## 基础-表格案例-axios-搜索功能-实现

>**`目标-任务`**使用watch实现前后台搜索功能
>
>​         1. 监听搜索内容框 
>
>​         2. 在监听函数中实现搜索逻辑
>
>​         3.  将返回结果设置给 当前数据对象
>
>​         4.   更换数据对象
>
>代码
>
>```js
>watch: {
>searchValue(newValue) {
>       if (newValue) {
>         axios
>           .get("http://localhost:3000/brands?name_like=" + newValue)
>           .then(result => {
>             this.list = result.data;
>           });
>       } else {
>         this.getList();
>       }
>      }
>   }
>```



## 基础-组件-组件体验

> **`目标：`**建立对于组件的认识
>
> * Vue实例
>
> 场景: 重复的**`页面结构`**,**`数据`**,**`逻辑`** 都可以抽提成一个**`组件`**  
>
> 对于复杂的结构来说 都可以通过抽提组件的方式 来简化开发过程
>
> - 简单 高效 不重复

## 基础-组件-组件特点

> **`目标`**认识组件特点
>
> 组件特点: 组件是一个**`特殊的 Vue实例`**
>
> 没有el => 有**`template`**=> HTML模板 
>
> 有 data,但是data是一个函数 => 是一个**`带返回值`**的函数 **`返回值是一个对象`** 
>
> Vue的组件和组件之间没有关系,是独立的,独立的数据 => return {   data数据 } =>  return new Object()
>
> 和实例相似之处:   data/methods/computed/watch  等一应俱全   Vue实例有的,它都有,没有el,data是一个函数
>
> **注意** 值得注意的是  data和Vue实例的区别为 组件中data为一个函数   没有el选项 
>
> template 代表其**`页面结构`** (有且只要一个根元素)
>
> 每个组件都是**`独立`**的 运行作用域  数据 逻辑没有任何关联

## 基础-组件-全局组件

> **`目标`**掌握如何实现一个全局组件
>
> 全局和局部: 注册方式不同 应用范围不同
>
> 路径: 实现一个全局组件
>
> ```js
> vue.js:620 [Vue warn]: Do not use built-in or reserved HTML elements as component id: menu
> 
> ```
>
> 如果遇到以上问题 说明命名不对
>
> 1  定义一个全局组件
>
> 2   写入组件选项
>
> 3 使用注册组件

```js
 // 注册组件名称 推荐 小写字母 加横向的结构
      Vue.component("content-a", {
        template: `<div>
        {{count}}
        </div>`,
        data() {
          return {
            count: 1
          };
        }
      });
// 注意  data中必须为一个返回对象的函数
// template必须有且只有一个根元素
```

**`任务`** 实现一个全局组件 完成 加减步进器

![./assets/step.png](assets\step.png)

## 基础-组件-局部组件

>  **`目标`**: 掌握 如何实现一个局部组件
>
>  路径: 局部组件的实现
>
>  ​        1 定义一个局部组件
>
>  ​        2 写入组件选项
>
>  ​        3 使用组件
>
>  ```js
>  new Vue({
>    el: "#app",
>    data: {},
>    methods:{ },
>    components:{
>        "content-a": {
>            template: `<div>
>        {{count}}
>        </div>`,
>        data() {
>          return {
>            count: 1
>          };
>        }
>    }
>  })
>  ```
>
>  
>
>  **注意**注册组件时,注册名不能为 - 分割的名称
>
>  **`任务`** 实现一个局部组件 完成 加减步进器
>
>  

## 基础-组件-组件嵌套

> **`目标`**掌握如何在组件中掌握嵌套
>
> * 我们可以在new Vue()实例中使用自定义组件,
> * 也可以在注册自定义组件时,嵌套另一个自定义组件,也就是**`父子组件`**的关系
>
> ```js
> var comA = {
>     template: `<div>我是子组件</div>`
>   };
>   var parentA = {
>     template: `<div>
>      我是父组件
>      <com-a></com-a>
>     </div>`,
>     components: {'com-a': comA }
>   };
>   var vm = new Vue({
>     el: "#app",
>     data: {},
>     methods: {},
>     components: {
>       'parent-a":parentA
>     }
>   });
> ```
>
> 局部组件 => 在谁的组件上注册 就只能在谁的**`组件模板(template)`**中使用
>
> **`任务`** 
>
> 1. 实现一个Vue实例
> 2. 自定义一个组件parentB，内容为我是父组件parentB
> 3. 自定义一个组件childA ,内容是我是子组件childA
> 4. 将在父组件中使用childA, 并在页面上实现显示两个parentB
>
> **`路径`**: 实现组件嵌套
>
> ​        1 定义多个组件 
>
> ​        2 组件对组件进行引用 
>
> ​        3 使用根组件
>
> ​       注意: 组件嵌套和全局 及局部组件没关系
>
> **`关于具体实现参考课程提供的代码`**

## 基础-组件-组件通信的几种情况

>**`目标`**：了解组件通信的几种情况（
>
>* 父组件 =》 子组件   需要将数据传给子组件 
>* 子组件 =》 父组件  如果父组件需要 子组件也可以传数据给父组件
>* 兄弟组件1 =》兄弟组件2 => eventBus => Vuex

## 基础-组件-父组件给子组件传值Props

>**`目标`**:掌握父组件用Props给子组件传值
>
>父子关系 => 父模板中使用了组件,父模板就是组件的父组件
>
>* props作用: 接收父组件传递的数据
>* props就是父组件给子组件标签上定义的**`属性`**
>
>```js
>1. props是组件的选项  定义接收属性
>2. props的值可以是字符串数组 props:["list"]
>3. props数组里面的元素称之为prop(属性) 属性=?值
>4. prop的值来源于外部的(组件的外部)
>5. prop(我们这里是lists)是组件的属性->自定义标签的属性
>6. prop的赋值位置(在使用组件时,通过标签属性去赋值)
>7. prop的用法和data中的数据用法一样
>```
>
>- **`注意`**: 父组件传递给子组件的数据是**`只读`**的,即**`只可以用,不可以改`**
>- 要改的话去父组件改=>通知子组件
>- 用props完成父组件给子组件传值  传值的属性都是定义在 子组件的标签上,可以采用v-bind的形式传递动态值
>- 定义props属性 在标签上定义属性  v-bind传递动态值
>- 在子组件中声明接收的属性
>- 在子组件中使用 组件 记住 属性只可以用 不可改
>
>**`任务`** 
>
>1. 定义子组件
>2. 在父组件中将 ["北京", "上海","天津"] 传递给子组件
>3. 在子组件中获取该数据 并采用v-for循环显示在页面上
>
>```html
>   components: {
>     a: {
>       template: "<b :name1='123'></b>",
>       components: {
>         b: {
>           props: ["name1"],
>           template: "<c :name2='234'></c>",
>           components: {
>             c: {
>               props: ["name2"],
>               template: "<d :name3='345'></d>",
>               components: {
>                 d: {
>                   props: ["name3"]
>                 }
>               }
>             }
>           }
>         }
>       }
>     }
>   }
>```
>
>
>
>**`路径`**: 
>
>      1. 定义父子组件 
>         2. 定义props接受父组件属性
>         3. 父组件中通过属性给子组件传值
>         4. 注册使用子组件
>
>```js
>const comA = {
>template: `<div>
><span v-for="(item,index) in list" :key="index">{{item}}</span>
></div>
>`,
>props: ["list"] // props可以是数组  也可以是对象
>};
>```
>
>**`关于具体实现参考课程提供的代码`**

## 基础-组件-子组件给父组件传值(自定义事件)

>  **`目标`**:掌握如何通过子组件给父组件传值
>
>  * 自定义事件 => **`$emit`** => 触发一个自定义事件 => 携带参数=>传递数据
>
>  ​    父组件如何监听子组件事件?
>
>  * 上个小节中,父组件通过props将值传给了子组件,那么子组件如何将数据传给父组件?
>  * 可通过在子组件中触发**`$emit`**事件,然后在父组件中监视此事件 进行追踪
>  * **`任务`**
>
>  1. 上一小节基础上  实现 点击子组件的城市时,将当前点击的城市传递给父组件,
>  2. 父组件 将 当前点击城市 通过props再次传递给子组件 
>  3. 子组件 根据当前选中和循环项目比对 得出 哪个城市 得到 select class 
>  4. 对 select  class进行样式赋值,使其 字体大小为40px  字体颜色为红色
>
>  **`注意`**：抛出事件名必须为全小写
>
>  **`路径`**:  点击子组件时  调用父组件的方法  改变当前的select
>
>  ​        1  定义子组件 
>
>  ​        2  定义props接收 父组件 数据 函数
>
>  ​        3  父组件给子组件传值  数据 和函数
>
>  ​        4  子组件点击事件绑定 父组件传递prop函数
>
>  **注意 !!!!!!!!!!!!!**       如果props有驼峰命名的情况 赋值时  需要拆成- 分割的形式 否则无法传递
>
>  例如
>
>  ```html
>  <p postTitle="hello world"></p> // 错误
>  <p post-title="hello world"></p> //正确
>  ```
>
>  **`关于具体实现参考课程提供的代码`**

>

## 基础-单页应用-SPA的特点

> **`目标`**  掌握SPA的特点 single  page  application
>
> * 传统模式 每个页面及其内容都需要从服务器一次次请求  如果网络差, 体验则会感觉很慢
> * spa模式, **`第一次`**加载 会将所有的资源都请求到页面 **`模块之间切换`**不会再请求服务器
>
> SPA优点

1. 用户体验好,因为前段操作几乎感受不到网络的延迟
2. 完全组件化开发 ,由于只有一个页面,所以原来属于一个个页面的工作被归类为一个个**`组件`**.

> 缺点

1. **`首屏`**加载慢->**`按需加载`** 不刷新页面 只请求js模块
2. 不利于SEO->**`服务端渲染`**(node->自己写路由->express-art-template+res.render())
3. **`开发难度高`**(框架) 相对于传统模式,有一些学习成本和应用成本

> vue适合开发SPA->什么是SPA+SPA特点
>
> SPA不利于SEO->搜索引擎排名靠前->搜素引擎机制->搜索引擎不能去找到局部刷新的网站内容

## 基础-单页应用-SPA-实现原理

> **`目标`** 掌握前段SPA的实现原理
>
> * SPA要实现 能够在前端自由切换模块 
> * SPA要能记忆当前切换的模块,并且刷新页面模块依然还在当前视图
> * SPA要实现在前端切换模块时,不能引起页面刷新,否则页面内容会被重置
>
> **`结论`**
>
> * 可以通过页面地址的锚链接来实现spa
> * hash(锚链接)位于链接地址 **`#`**之后
> * hash值的改变**`不会触发`**页面刷新
> * hash值是url地址的一部分,会存储在页面地址上 我们可以获取到
> * 可以通过**`事件监听`**hash值得改变
> * 拿到了hash值,就可以根据不同的hash值进行不同的**`模块切换`**

## 基础-路由-js实现路由

>**`目标`** 掌握如何用纯js逻辑实现一个前端路由功能
>
>* 通过上一个小节内容可以得出 采用**`hash值改变`**的特性来进行前端路由切换
>
>**`任务`**
>
>1. 在页面上实现4个链接,北京,上海,天津,重庆
>2. 实现点击4个链接时,页面上显示对应的城市名称
>3. 并且刷新页面之后,上次切换的城市还在
>
>**`路径`**: 
>
>​      1.  实现导航结构 
>
>​      2.  监听hash改变
>
>      3.  根据改变切换视图
>
>**`关于具体实现参考课程提供的代码`**

## 基础-路由-vue-router-文档

> **`目标`**  了解vue-router是什么
>
> * Vue-Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建**单页面**应用变得易如反掌   它是一个插件
> * 实现根据不同的请求地址 而**`显示不同的组件`**
> * 如果要使用 vue开发项目,前端路由功能**`必须使用`**vue-router来实现
> * vuejs 中并没有vue-router 如果想要用vue-router ,需要单独安装下载
>
> 

## 基础-路由-vue-router-体验及使用步骤

>**`目标`**掌握如何在页面中使用vue-router
>
>1. 导入vue和vue-router
>2. 设置HTML中的内容
>
>```html
><!-- router-link 最终会被渲染成a标签，to指定路由的跳转地址 -->
><router-link to="/users">用户管理</router-link>
>
><!-- 路由匹配到的组件将渲染在这里 -->
><router-view></router-view>
>```
>
>3. 创建组件
>
>   ```js
>   // 创建组件
>   // 组件也可以放到单独的js文件中
>   var Home = {
>       template: '<div>这是Home内容</div>'
>   };
>   var Users = {
>       template: '<div>这是用户管理内容</div>'
>   };
>   ```
>
>4. 实例化路由对象,配置路由规则
>
>  ```js
>// 配置路由规则
>var router = new VueRouter({
>    routes: [
>        { name: 'home', path: '/', component: Home },
>        { name: 'users', path: '/users', component: Users }
>    ]
>});
>  ```
>
>5. vue实例挂载router实例
>
>```js
>var vm = new Vue({
>    el: '#app',
>    router
>});
>```
>
>**`任务`**: 
>
>1. 使用vue-router实现一个前端路由
>2. 导航为 勇士 湖人 快船 火箭
>3. 勇士 =>库里-汤普森  湖人 =>詹姆斯-浓眉  快船 => 泡椒-卡哇伊  火箭 => 灯泡

**`关于具体实现参考课程提供的代码`**

## 基础-路由-vue-router-动态路由

>  **`目标`**掌握Vue-router的动态路由如何使用
>
>  * 点击**`列表页`** 跳转到**`详情页`**时,跳转的链接需要携带参数,会导致**`path`**不同
>  * 当path不同却需要对应同一个组件时,需要用到动态路由这一概念
>
>  此时可以通过路由传参来实现，具体步骤如下：
>
>  1. 路由规则中增加参数，在path最后增加 **:id**
>
>     ```js
>     { name: 'users', path: '/users/:id', component: Users },
>     ```
>
>  2. 通过 <router-link> 传参，在路径上传入具体的值
>
>     ```html
>     <router-link to="/users/120">用户管理</router-link>
>     ```
>
>  3. 在组件内部可以使用，**this.$route** 获取当前路由对象
>
>     ```js
>     var Users = {
>         template: '<div>这是用户管理内容 {{ $route.params.id }}</div>',
>         mounted() {
>             console.log(this.$route.params.id);
>         }
>     };
>     ```
>
>  **`任务`**
>
>  1. 在上一小节任务中,将多个球队指向的组件改为同一个组件
>  2. 在导航中传入参数 (当前点击的名称)
>  3. 在组件中显示的内容: 我是 "传入的球队"队的粉丝
>
>  **注意** 动态路由的参数 可以通过 vue实例.$route.params获取
>
>  **`关于具体实现参考课程提供的代码`**

## 基础-路由-vue-router-to属性赋值

>**`目标`**掌握 vue-router中的to的多种赋值方式
>
>* to 有多种赋值方式  

```html
<!-- 常规跳转 -->
      <!-- <router-link to="/sport">体育</router-link> -->
      <!-- 变量 -->
      <!-- <router-link :to="path">体育</router-link> -->
      <!-- 根据对象name跳转 -->
      <!-- <router-link :to="{name:'abcdefg'}">体育</router-link> -->
      <!-- 根据对象path跳转 -->
      <!-- <router-link :to="{path:'/sport'}">体育</router-link> -->
      <!-- 带参数的跳转 -->
      <router-link :to="{name:'abcdefg',params:{a:1}}">体育</router-link>
```

**`任务`**

1. 用vue-router实例化路由 
2. 导航为 北京 上海 
3. 分别采用四种赋值方式 将上海跳转到对应的组件
4. 在北京跳转时 实现 带参数的跳转

**`关于具体实现参考课程提供的代码`**

## 基础-路由-vue-router-重定向

>**`目标`**掌握路由-vue-router-重定向
>
>场景: 当希望某个页面被强制中转时  可采用redirect 进行路由重定向设置
>
>```json
>{
>       path: "/sport",
>       redirect: "/news", // 强制跳转新闻页
>       component: {
>         template: `<div>体育</div>`
>       }
>     },
>```
>
>**`任务`**
>
>1. 实例化一个vue路由
>2. 导航为 bj => 北京  sh => 上海 tj => 天津
>3. 实现当跳转到天津时 直接重定向到北京
>
>**`关于具体实现参考课程提供的代码`**

## 基础-路由-vue-router-编程式导航

>**`目标`**掌握路由-vue-router-编程式导航
>
>* 跳转不同的组件 不仅仅可以用router-link 还可以采用代码行为
>* (Vue实例)this.$router 可以拿到当前路由对象的实例
>* 路由对象的实例方法 有 push  replace, go()  goBack
>* push 方法 相当于往历史记录里推了一条记录 如果点击返回 会回到上一次的地址
>* replace方法 想相当于替换了当前的记录  历史记录并没有多 但是地址会变
>* go(数字) 代表希望是前进还是回退,当数字大于0 时 就是前进 n(数字)次,小于0时,就是后退n(数字)次
>* goBack() 代表返回上个页面
>
>可以通过vue实例 获取当前的路由实例 $router 
>
>```js
>goPage() {
>             // 跳转到新闻页面
>             this.$router.push({
>               path: "/news"
>             });
>           }
>```
>
>**`任务`**
>
>1. 实例化一个导航路由
>2. 导航为 A, B, C ,D 
>3. 实现A => B , B => C, 然后从C返回时,直接回到A
>4. 实现A => B ,B => C , C =>D 从D返回时 不能返回
>5. 实现A => B ,B => C , C =>D 从D返回直接返回到A 在A中直接前进到D

## 基础-路由-vue-router-routerlink-tag-激活样式

> **`目标`**: 掌握如何设置当前激活路由的样式
>
> * 当前路由在导航中是拥有激活class样式的
>
> 
>
> 审查导航元素,可以发现 激活样式
>
> ```html
> 	<a href="#/news" class="router-link-exact-active router-link-active">新闻</a>
> ```
>
> 设置激活class样式即可
>
> **`任务`**
>
> 1. 实例化一个vue-router导航
> 2. 北京- 上海- 天津
>
>    



